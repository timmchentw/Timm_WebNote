# 物件導向

## SOLID原則

### SRP 單一職責原則

避免混入過多邏輯，易於共用、抽換與測試邏輯 (關注點分離、專業分工)

* 說法一: 類別遵守單一職責
* 說法二: 類別對單一角色負責
* 實踐: 一次盡量只做一件事，或只做一個單純的動作 
* 舉例: 如讀寫DB、讀取Excel、而不是讀取Excel後再讀寫DB

### OCP 開放封閉原則

對擴充進行開放、對修改進行封閉

* 遵守SRP，會對修改的範圍減小
* 遵守ISP，擴充以繼承介面的方式
* 實踐: 遵守其他原則

### LSP 林氏替換原則

避免預設立場，使方法可隨時抽換而不會出錯

* 實踐1: input/output以Enum條列、想像這個功能給其他人改會不會爆炸
* 實踐2: DI相依性注入方法有助於替換Class
* 舉例: 我知道方法回傳的string有哪幾種內容，再針對他們做各別規則處理

### ISP 介面隔離原則

使用介面隔離"細節方法" (如產品名稱、公司名、技術方式)，避免太依賴特定情境

* 實踐1: 常變動、多參數的方法減少Static方式撰寫，改用繼承介面的方式增加彈性
* 實踐2: 介面的方法參數不要直接引用"特定類別"，如DB Model、API Body，應撰寫成通用Dto，並在方法內自行轉換格式
* 實踐3: 介面盡量不改動為最高原則
* 實踐4: DI相依性注入方法有助於將細節方法隱藏起來
* 舉例: 平常使用Azure上傳雲端檔案的方法、後來改用AWS，則希望能在Interface不改動的情況下，抽換成AWS方法
* 注意: 繼承Class也是高耦合相依，

### DIP 反向依賴原則

邏輯依賴的方向不只是單向(高階→低階)，而是共同依賴抽象

* 舉例: 儲存資料方法依賴"資料層"、"資料層"以API方法實作

# 重構

## Comment

* function命名精準取代註解
* 避免無用的Code留著 (版控取代)
* 盡量以"為何這麼做"為目的，而不是翻譯、解釋

## 排版

* 換行進行分類
* 注意public, private方法的排版分類
* 使用自動化工具進行自動排版 (e.g. Code cleanup)

## 命名

* 遵守語言的命名方式
  * C#
    * Class, Method, Property: Pascal
    * Parameter: Camel
  * Javascript
    * Camel
* 口語化、口語化、口語化
* 方法能一看就知道在做甚麼 (GetRecordById, ConvertDataAndLog...)

## 方法

* 以強型別取代弱型別，避免Runtime時才出錯
* 超過3個Parameter的方法改以Class作為input
* 不要寫波動拳! 遵守SRP可將邏輯分散
  
  ```C#
  if ()
  {
      if ()
      {
          if ()
          {

          }
      }
  }
  ```